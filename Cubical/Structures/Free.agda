{-# OPTIONS --cubical #-}

module Cubical.Structures.Free where

open import Cubical.Foundations.Everything
open import Cubical.Foundations.Equiv
open import Cubical.Functions.Image
open import Cubical.HITs.PropositionalTruncation as P
open import Cubical.Data.Nat
open import Cubical.Data.List as L
open import Cubical.Data.Sigma
open import Cubical.Reflection.RecordEquiv
open import Cubical.HITs.SetQuotients as Q
open import Agda.Primitive

open import Cubical.Structures.Sig
open import Cubical.Structures.Str
open import Cubical.Structures.Tree
open import Cubical.Structures.Eq

-- defines a free structure on a signature and equations
module Definition {f a e n s : Level} (Ïƒ : Sig f a) (Ï„ : EqSig e (â„“-max n s)) (Îµ : seq {n = â„“-max n s} Ïƒ Ï„) where
  ns : Level
  ns = â„“-max n s

  record Free (h : HLevel) : Type (â„“-suc (â„“-max f (â„“-max a (â„“-max e ns)))) where
    field
      F : (X : Type n) -> Type ns
      Î· : {X : Type n} -> X -> F X
      Î± : {X : Type n} -> sig Ïƒ (F X) -> F X
      sat : {X : Type n} -> <_,_> {n = ns} (F X) Î± âŠ¨ Îµ
      isFree : {X : Type n} {ğ”œ : struct ns Ïƒ} (H : isOfHLevel h (ğ”œ .car)) (Ï• : ğ”œ âŠ¨ Îµ)
            -> isEquiv (\(f : structHom {x = ns} < F X , Î± > ğ”œ) -> f .fst âˆ˜ Î·)

    ext : {X : Type n} {ğ”œ : struct ns Ïƒ} (H : isOfHLevel h (ğ”œ .car)) (Ï• : ğ”œ âŠ¨ Îµ)
       -> (hom : X -> ğ”œ .car) -> structHom < F X , Î± > ğ”œ
    ext h Ï• = invIsEq (isFree h Ï•)

    ext-Î² : {X : Type n} {ğ”œ : struct ns Ïƒ}
            (H : isOfHLevel h (ğ”œ .car)) (Ï• : ğ”œ âŠ¨ Îµ) (Hom : structHom < F X , Î± > ğ”œ)
         -> ext H Ï• (Hom .fst âˆ˜ Î·) â‰¡ Hom
    ext-Î² h Ï• Hom = retIsEq (isFree h Ï•) Hom

    ext-Î· : {X : Type n} {ğ”œ : struct ns Ïƒ}
            (H : isOfHLevel h (ğ”œ .car)) (Ï• : ğ”œ âŠ¨ Îµ) (h : X -> ğ”œ .car)
         -> (ext H Ï• h .fst) âˆ˜ Î· â‰¡ h
    ext-Î· H Ï• h = secIsEq (isFree H Ï•) h

-- -- constructions of a free structure on a signature and equations
-- -- TODO: generalise the universe levels!!
-- -- using a HIT
-- module Construction {f a e n : Level} (Ïƒ : Sig f a) (Ï„ : EqSig e n) (Îµ : seq Ïƒ Ï„) where
-- 
--   data Free (X : Type n) : Type (â„“-suc (â„“-max f (â„“-max a (â„“-max e n)))) where
--       Î· : X -> Free X
--       Î± : sig Ïƒ (Free X) -> Free X
--       sat : mkStruct (Free X) Î± âŠ¨ Îµ

--  freeStruct : (X : Type) -> struct Ïƒ
--  car (freeStruct X) = Free X
--  alg (freeStruct _) = Î±
--
--  module _ (X : Type) (ğ”œ : struct Ïƒ) (Ï• : ğ”œ âŠ¨ Îµ) where

    -- private
    --   Y = ğ”œ .fst
    --   Î² = ğ”œ .snd

    -- ext : (h : X -> Y) -> Free X -> Y
    -- ext h (Î· x) = h x
    -- ext h (Î± (f , o)) = Î² (f , (ext h âˆ˜ o))
    -- ext h (sat e Ï i) = Ï• e (ext h âˆ˜ Ï) {!i!}

    -- module _  where
    --   postulate
    --     Fr : Type (â„“-max (â„“-max f a) n)
    --     FÎ± : sig Ïƒ Fr -> Fr
    --     Fs : sat Ïƒ Ï„ Îµ (Fr , FÎ±)

    --   module _ (Y : Type (â„“-max (â„“-max f a) n)) (Î± : sig Ïƒ Y -> Y) where
    --     postulate
    --       Frec : sat Ïƒ Ï„ Îµ (Y , Î±) -> Fr -> Y
    --       Fhom : (p : sat Ïƒ Ï„ Îµ (Y , Î±)) -> walgIsH Ïƒ (Fr , FÎ±) (Y , Î±) (Frec p)
    --       Feta : (p : sat Ïƒ Ï„ Îµ (Y , Î±)) (h : Fr -> Y) -> walgIsH Ïƒ (Fr , FÎ±) (Y , Î±) h -> Frec p â‰¡ h
    
-- -- using a quotient
-- module Construction2 (Ïƒ : Sig â„“-zero â„“-zero) (Ï„ : EqSig â„“-zero â„“-zero) (Îµ : seq Ïƒ Ï„) where
-- 
--   -- congruence relation generated by equations
--   data _â‰ˆ_ {X : Type} : Tree Ïƒ X -> Tree Ïƒ X -> Type (â„“-suc â„“-zero) where
--     â‰ˆ-refl : âˆ€ t -> t â‰ˆ t
--     â‰ˆ-sym : âˆ€ t s -> t â‰ˆ s -> s â‰ˆ t
--     â‰ˆ-trans : âˆ€ t s r -> t â‰ˆ s -> s â‰ˆ r -> t â‰ˆ r
--     â‰ˆ-cong : (f : Ïƒ .symbol) -> {t s : Ïƒ .arity f -> Tree Ïƒ X}
--           -> ((a : Ïƒ .arity f) -> t a â‰ˆ s a)
--           -> node (f , t) â‰ˆ node (f , s)
--     â‰ˆ-eqs : (ğ”œ : struct {â„“-zero} {â„“-zero} {â„“-zero} Ïƒ) (Ï• : ğ”œ âŠ¨ Îµ)
--          -> (e : Ï„ .name) (Ï : X -> ğ”œ .car)
--          -> âˆ€ t s -> sharp Ïƒ {ğ”œ = ğ”œ} Ï t â‰¡ sharp Ïƒ {ğ”œ = ğ”œ} Ï s
--          -> t â‰ˆ s
-- 
--   Free : Type -> Typeâ‚
--   Free X = Tree Ïƒ X / _â‰ˆ_
-- 
--   -- freeAlg : (X : Type) -> sig Ïƒ (Free X) -> Free X
--   -- freeAlg X (f , i) = Q.[ node (f , {!!}) ] -- needs choice?
-- 
--   -- freeStruct : (X : Type) -> struct Ïƒ
--   -- freeStruct X = Free X , freeAlg X
-- 
--   -- module _ (X : Type) (ğ”œ : struct Ïƒ) (Ï• : ğ”œ âŠ¨ Îµ) where
-- 
--   --   private
--   --     Y = ğ”œ .fst
--   --     Î² = ğ”œ .snd
