{-# OPTIONS --cubical #-}

-- Definition taken from https://drops.dagstuhl.de/opus/volltexte/2023/18395/pdf/LIPIcs-ITP-2023-20.pdf
module Cubical.Structures.Set.CMon.Bag where

open import Cubical.Core.Everything
open import Cubical.Foundations.Everything
open import Cubical.Foundations.Isomorphism
open import Cubical.Data.List
open import Cubical.Data.Nat
open import Cubical.Data.Nat.Order
open import Cubical.Data.Fin
open import Cubical.Data.Sum as ‚äé
open import Cubical.Data.Sigma
import Cubical.Data.Empty as ‚ä•

import Cubical.Structures.Set.Mon.Desc as M
import Cubical.Structures.Set.CMon.Desc as M
import Cubical.Structures.Free as F
open import Cubical.Structures.Set.Mon.Array as A
open import Cubical.Structures.Sig
open import Cubical.Structures.Str public
open import Cubical.Structures.Tree
open import Cubical.Structures.Eq
open import Cubical.Structures.Arity hiding (_/_)
open import Cubical.Structures.Set.CMon.QFreeMon
open import Cubical.Relation.Nullary

open Iso

private
  variable
    ‚Ñì ‚Ñì' ‚Ñì'' : Level
    A : Type ‚Ñì

SymmAction : ‚àÄ {A : Type ‚Ñì} -> Array A -> Array A -> Type ‚Ñì
SymmAction (n , v) (m , w) = Œ£[ œÉ ‚àà Iso (Fin n) (Fin m) ] v ‚â° w ‚àò œÉ .fun

_‚âà_ = SymmAction

symm-length‚â° : {n m : ‚Ñï} -> Iso (Fin n) (Fin m) -> n ‚â° m 
symm-length‚â° {n = n} {m = m} œÉ = Fin-inj n m (isoToPath œÉ)

symm-refl : {as : Array A} -> SymmAction as as
symm-refl {as = as} = idIso , refl

symm-sym : {as bs : Array A} -> SymmAction as bs -> SymmAction bs as
symm-sym {as = (n , f)} {bs = (m , g)} (œÉ , p) =
  invIso œÉ , congS (g ‚àò_) (sym (funExt (œÉ .rightInv)))
           ‚àô congS (_‚àò œÉ .inv) (sym p)

symm-trans : {as bs cs : Array A} -> SymmAction as bs -> SymmAction bs cs -> SymmAction as cs
symm-trans {as = (n , f)} {bs = (m , g)} {cs = (o , h)} (œÉ , p) (œÑ , q) =
  compIso œÉ œÑ , sym
    ((h ‚àò œÑ .fun) ‚àò œÉ .fun ‚â°‚ü® congS (_‚àò œÉ .fun) (sym q) ‚ü©
    g ‚àò œÉ .fun ‚â°‚ü® sym p ‚ü©
    f ‚àé)

Array‚â°-len : {as bs : Array A} -> as ‚â° bs -> as .fst ‚â° bs .fst
Array‚â°-len {as = (n , f)} {bs = (m , g)} p = cong fst p

Fin+-cong : {n m n' m' : ‚Ñï} -> Iso (Fin n) (Fin n') -> Iso (Fin m) (Fin m') -> Iso (Fin (n + m)) (Fin (n' + m'))
Fin+-cong {n} {m} {n'} {m'} œÉ œÑ =
  compIso (Fin‚âÖFin+Fin n m) (compIso (‚äéIso œÉ œÑ) (invIso (Fin‚âÖFin+Fin n' m')))

‚äéIso-eta : {A B A' B' : Type ‚Ñì} {C : Type ‚Ñì'} (f : A' -> C) (g : B' -> C)
        -> (œÉ : Iso A A') (œÑ : Iso B B')
        -> ‚äé.rec (f ‚àò œÉ .fun) (g ‚àò œÑ .fun) ‚â° ‚äé.rec f g ‚àò ‚äéIso œÉ œÑ .fun
‚äéIso-eta f g œÉ œÑ i (inl a) = f (œÉ .fun a)
‚äéIso-eta f g œÉ œÑ i (inr b) = g (œÑ .fun b)

‚äéSwap-eta : {A B : Type ‚Ñì} {C : Type ‚Ñì'} (f : A -> C) (g : B -> C)
        -> ‚äé.rec g f ‚àò ‚äé-swap-Iso .fun ‚â° ‚äé.rec f g
‚äéSwap-eta f g i (inl a) = f a
‚äéSwap-eta f g i (inr b) = g b

symm-cong : {as bs cs ds : Array A} -> as ‚âà bs -> cs ‚âà ds -> (as ‚äï cs) ‚âà (bs ‚äï ds)
symm-cong {as = n , f} {bs = n' , f'} {m , g} {m' , g'} (œÉ , p) (œÑ , q) =
  Fin+-cong œÉ œÑ ,
  (
    combine n m f g
  ‚â°‚ü® cong‚ÇÇ (combine n m) p q ‚ü©
    combine n m (f' ‚àò œÉ .fun) (g' ‚àò œÑ .fun)
  ‚â°‚ü®‚ü©
    ‚äé.rec (f' ‚àò œÉ .fun) (g' ‚àò œÑ .fun) ‚àò finSplit n m
  ‚â°‚ü® congS (_‚àò finSplit n m) (‚äéIso-eta f' g' œÉ œÑ) ‚ü©
    ‚äé.rec f' g' ‚àò ‚äéIso œÉ œÑ .fun ‚àò finSplit n m
  ‚â°‚ü®‚ü©
    ‚äé.rec f' g' ‚àò idfun _ ‚àò ‚äéIso œÉ œÑ .fun ‚àò finSplit n m
  ‚â°‚ü® congS (Œª f -> ‚äé.rec f' g' ‚àò f ‚àò ‚äéIso œÉ œÑ .fun ‚àò finSplit n m) (sym (funExt (Fin‚âÖFin+Fin n' m' .rightInv))) ‚ü©
    ‚äé.rec f' g' ‚àò (Fin‚âÖFin+Fin n' m' .fun ‚àò Fin‚âÖFin+Fin n' m' .inv) ‚àò ‚äéIso œÉ œÑ .fun ‚àò finSplit n m
  ‚â°‚ü®‚ü©
    (‚äé.rec f' g' ‚àò Fin‚âÖFin+Fin n' m' .fun) ‚àò (Fin‚âÖFin+Fin n' m' .inv ‚àò ‚äéIso œÉ œÑ .fun ‚àò finSplit n m)
  ‚â°‚ü®‚ü©
    combine n' m' f' g' ‚àò Fin+-cong œÉ œÑ .fun
  ‚àé)

Fin+-comm : (n m : ‚Ñï) -> Iso (Fin (n + m)) (Fin (m + n))
Fin+-comm n m = compIso (Fin‚âÖFin+Fin n m) (compIso ‚äé-swap-Iso (invIso (Fin‚âÖFin+Fin m n)))

symm-comm : {as bs : Array A} -> (as ‚äï bs) ‚âà (bs ‚äï as)
symm-comm {as = n , f} {bs = m , g} =
  Fin+-comm n m , sym
    (
      ‚äé.rec g f ‚àò finSplit m n ‚àò Fin‚âÖFin+Fin m n .inv ‚àò ‚äé-swap-Iso .fun ‚àò Fin‚âÖFin+Fin n m .fun
    ‚â°‚ü®‚ü©
      ‚äé.rec g f ‚àò (Fin‚âÖFin+Fin m n .fun ‚àò Fin‚âÖFin+Fin m n .inv) ‚àò ‚äé-swap-Iso .fun ‚àò Fin‚âÖFin+Fin n m .fun
    ‚â°‚ü® congS (Œª h -> ‚äé.rec g f ‚àò h ‚àò ‚äé-swap-Iso .fun ‚àò Fin‚âÖFin+Fin n m .fun) (funExt (Fin‚âÖFin+Fin m n .rightInv)) ‚ü©
      ‚äé.rec g f ‚àò ‚äé-swap-Iso .fun ‚àò Fin‚âÖFin+Fin n m .fun
    ‚â°‚ü® congS (_‚àò Fin‚âÖFin+Fin n m .fun) (‚äéSwap-eta f g) ‚ü©
      ‚äé.rec f g ‚àò Fin‚âÖFin+Fin n m .fun
    ‚àé)

module _ {‚ÑìA ‚ÑìB} {A : Type ‚ÑìA} {ùîú : struct ‚ÑìB M.MonSig} (isSetùîú : isSet (ùîú .car)) (ùîú-cmon : ùîú ‚ä® M.CMonSEq) (f : A -> ùîú .car) where
  module ùîú = M.CMonSEq ùîú ùîú-cmon

  f‚ôØ-hom = A.Free.‚ôØ-isMonHom isSetùîú (M.cmonSatMon ùîú-cmon) f

  f‚ôØ : Array A -> ùîú .car
  f‚ôØ = f‚ôØ-hom .fst

  f‚ôØ-hom-‚äï : (as bs : Array A) -> f‚ôØ (as ‚äï bs) ‚â° f‚ôØ as ùîú.‚äï f‚ôØ bs
  f‚ôØ-hom-‚äï as bs =
    f‚ôØ (as ‚äï bs) ‚â°‚ü® sym ((f‚ôØ-hom .snd) M.`‚äï (lookup (as ‚à∑ bs ‚à∑ []))) ‚ü©
    ùîú .alg (M.`‚äï , (Œª w -> f‚ôØ (lookup (as ‚à∑ bs ‚à∑ []) w))) ‚â°‚ü® ùîú.‚äï-eta (lookup (as ‚à∑ bs ‚à∑ [])) f‚ôØ ‚ü©
    f‚ôØ as ùîú.‚äï f‚ôØ bs ‚àé

  f‚ôØ-comm : (as bs : Array A) -> f‚ôØ (as ‚äï bs) ‚â° f‚ôØ (bs ‚äï as)
  f‚ôØ-comm as bs =
    f‚ôØ (as ‚äï bs) ‚â°‚ü® f‚ôØ-hom-‚äï as bs ‚ü©
    f‚ôØ as ùîú.‚äï f‚ôØ bs ‚â°‚ü® ùîú.comm (f‚ôØ as) (f‚ôØ bs) ‚ü©
    f‚ôØ bs ùîú.‚äï f‚ôØ as ‚â°‚ü® sym (f‚ôØ-hom-‚äï bs as) ‚ü©
    f‚ôØ (bs ‚äï as) ‚àé

  fpred : ‚àÄ {n} -> Fin (suc (suc n)) -> Fin (suc n)
  fpred (zero , p) = fzero
  fpred (suc w , p) = w , pred-‚â§-pred p

  fsuc‚àòfpred : ‚àÄ {n} -> (x : Fin (suc (suc n))) -> ¬¨ x ‚â° fzero -> fsuc (fpred x) ‚â° x
  fsuc‚àòfpred (zero , p) q = ‚ä•.rec (q (Œ£‚â°Prop (Œª _ -> isProp‚â§) refl))
  fsuc‚àòfpred (suc k , p) q = Œ£‚â°Prop (Œª _ -> isProp‚â§) refl

  fpred‚àòfsuc : ‚àÄ {n} -> (x : Fin (suc n)) -> fpred (fsuc x) ‚â° x
  fpred‚àòfsuc (k , p) = Œ£‚â°Prop (Œª _ -> isProp‚â§) refl

  autInvIs0 : ‚àÄ {n} -> (aut : Iso (Fin (suc (suc n))) (Fin (suc (suc n))))
            -> aut .fun fzero ‚â° fzero
            -> inv aut fzero ‚â° fzero
  autInvIs0 aut q =
    inv aut fzero ‚â°‚ü® congS (inv aut) (sym q) ‚ü©
    inv aut (aut .fun fzero) ‚â°‚ü® aut .leftInv fzero ‚ü©
    fzero ‚àé

  autSucNot0 : ‚àÄ {n} -> (aut : Iso (Fin (suc (suc n))) (Fin (suc (suc n))))
            -> (x : Fin (suc n))
            -> aut .fun fzero ‚â° fzero
            -> ¬¨ aut .fun (fsuc x) ‚â° fzero
  autSucNot0 aut x p q = znots (cong fst (isoFunInjective aut _ _ (p ‚àô sym q)))

  punchOutZero : ‚àÄ {n} (aut : Iso (Fin (suc (suc n))) (Fin (suc (suc n)))) -> aut .fun fzero ‚â° fzero
                -> Iso (Fin (suc n)) (Fin (suc n))
  punchOutZero {n = n} aut p =
    iso (punch aut) (punch (invIso aut)) (punch‚àòpunch aut p) (punch‚àòpunch (invIso aut) (autInvIs0 aut p)) 
    where
    punch : Iso (Fin (suc (suc n))) (Fin (suc (suc n))) -> _
    punch aut = fpred ‚àò aut .fun ‚àò fsuc
    punch‚àòpunch : (aut : Iso (Fin (suc (suc n))) (Fin (suc (suc n))))
                -> aut .fun fzero ‚â° fzero
                -> (x : Fin (suc n))
                -> punch aut (punch (invIso aut) x) ‚â° x
    punch‚àòpunch aut p x =
        punch aut (punch (invIso aut) x)
      ‚â°‚ü®‚ü©
        (fpred (aut .fun ((fsuc ‚àò fpred) (aut .inv (fsuc x)))))
      ‚â°‚ü® congS (fpred ‚àò aut .fun) (fsuc‚àòfpred (aut .inv (fsuc x)) (autSucNot0 (invIso aut) x (autInvIs0 aut p))) ‚ü©
        (fpred (aut .fun (aut .inv (fsuc x))))
      ‚â°‚ü® congS fpred (aut .rightInv (fsuc x)) ‚ü©
        (fpred (fsuc x))
      ‚â°‚ü® fpred‚àòfsuc x ‚ü©
        x ‚àé

  punchOutZero‚â°fsuc : ‚àÄ {n} (aut : Iso (Fin (suc (suc n))) (Fin (suc (suc n)))) -> (aut-0‚â°0 : aut .fun fzero ‚â° fzero)
                    -> (w : Fin (suc n)) -> aut .fun (fsuc w) ‚â° fsuc (punchOutZero aut aut-0‚â°0 .fun w)
  punchOutZero‚â°fsuc aut aut-0‚â°0 w = sym (fsuc‚àòfpred _ (autSucNot0 aut w aut-0‚â°0))

  finSubst : ‚àÄ {n m} -> n ‚â° m -> Fin n -> Fin m
  finSubst {n = n} {m = m} p (k , q) = k , (subst (k <_) p q)

  finIso : ‚àÄ {n m} -> n ‚â° m -> Iso (Fin n) (Fin m)
  finIso {n = n} {m = m} p = iso
    (finSubst p)
    (finSubst (sym p))
    (Œª (k , q) -> Œ£‚â°Prop (Œª _ -> isProp‚â§) refl)
    (Œª (k , q) -> Œ£‚â°Prop (Œª _ -> isProp‚â§) refl)

  swapAut : ‚àÄ {n} (aut : Iso (Fin (suc n)) (Fin (suc n))) -> Iso (Fin (suc n)) (Fin (suc n))
  swapAut {n = n} aut =
    compIso (finIso (sym cutoff+- ‚àô +-comm cutoff _)) (compIso (Fin+-comm (m ‚à∏ cutoff) cutoff) (compIso (finIso cutoff+-) aut))
    where
    m : ‚Ñï
    m = suc n

    cutoff : ‚Ñï
    cutoff = (aut .inv fzero) .fst

    cutoff< : cutoff < m
    cutoff< = (aut .inv fzero) .snd

    cutoff+- : cutoff + (m ‚à∏ cutoff) ‚â° m
    cutoff+- =
      cutoff + (m ‚à∏ cutoff) ‚â°‚ü® +-comm cutoff _ ‚ü©
      (m ‚à∏ cutoff) + cutoff ‚â°‚ü® ‚â§-‚à∏-+-cancel (<-weaken cutoff<) ‚ü©
      m ‚àé

  swapAut0‚â°0 : ‚àÄ {n} (aut : Iso (Fin (suc (suc n))) (Fin (suc (suc n)))) -> swapAut aut .fun fzero ‚â° fzero
  swapAut0‚â°0 {n = n} aut =
      aut .fun (finSubst cutoff+- (‚äé.rec finCombine-inl finCombine-inr (fun ‚äé-swap-Iso (finSplit (m ‚à∏ cutoff) cutoff (0 , _)))))
    ‚â°‚ü® congS (Œª z -> aut .fun (finSubst cutoff+- (‚äé.rec (finCombine-inl {m = cutoff}) (finCombine-inr {m = cutoff}) (fun ‚äé-swap-Iso z)))) (finSplit-beta-inl 0 0<m-cutoff _) ‚ü©
      aut .fun (aut .inv fzero .fst + 0 , _)
    ‚â°‚ü® congS (aut .fun) (Œ£‚â°Prop (Œª _ -> isProp‚â§) (+-zero (aut .inv (0 , suc-‚â§-suc zero-‚â§) .fst) ‚àô congS (fst ‚àò aut .inv) (Œ£‚â°Prop (Œª _ -> isProp‚â§) refl))) ‚ü©
      aut .fun (aut .inv fzero)
    ‚â°‚ü® aut .rightInv fzero ‚ü©
      fzero ‚àé
    where
    m : ‚Ñï
    m = suc (suc n)

    cutoff : ‚Ñï
    cutoff = (aut .inv fzero) .fst

    cutoff< : cutoff < m
    cutoff< = (aut .inv fzero) .snd

    cutoff+- : cutoff + (m ‚à∏ cutoff) ‚â° m
    cutoff+- =
      cutoff + (m ‚à∏ cutoff) ‚â°‚ü® +-comm cutoff _ ‚ü©
      (m ‚à∏ cutoff) + cutoff ‚â°‚ü® ‚â§-‚à∏-+-cancel (<-weaken cutoff<) ‚ü©
      m ‚àé

    0<m-cutoff : 0 < m ‚à∏ cutoff
    0<m-cutoff = n‚à∏l>0 m cutoff cutoff<

  swapAutToAut : ‚àÄ {n} (zs : Fin (suc (suc n)) -> A) (aut : Iso (Fin (suc (suc n))) (Fin (suc (suc n))))
               -> f‚ôØ (suc (suc n) , zs ‚àò swapAut aut .fun) ‚â° f‚ôØ (suc (suc n) , zs ‚àò aut .fun)
  swapAutToAut {n = n} zs aut =
      f‚ôØ (suc (suc n) , zs ‚àò swapAut aut .fun)
    ‚â°‚ü® congS f‚ôØ (Œ£PathP {x = m , zs ‚àò swapAut aut .fun} (sym cutoff+- ‚àô +-comm cutoff _ , toPathP (funExt lemma-Œ±))) ‚ü©
      f‚ôØ (((m ‚à∏ cutoff) , (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff _ ‚àò inr))
        ‚äï (cutoff , (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff _ ‚àò inl)))
    ‚â°‚ü® f‚ôØ-comm ((m ‚à∏ cutoff) , (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff _ ‚àò inr)) _ ‚ü©
      f‚ôØ ((cutoff , (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff _ ‚àò inl))
        ‚äï ((m ‚à∏ cutoff) , (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff _ ‚àò inr)))
    ‚â°‚ü® congS f‚ôØ (Œ£PathP {x = cutoff + (m ‚à∏ cutoff) , _} {y = m , zs ‚àò aut .fun} (cutoff+- , toPathP (funExt lemma-Œ≤))) ‚ü©
      f‚ôØ (suc (suc n) , zs ‚àò aut .fun) ‚àé
    where
    m : ‚Ñï
    m = suc (suc n)

    cutoff : ‚Ñï
    cutoff = (aut .inv fzero) .fst

    cutoff< : cutoff < m
    cutoff< = (aut .inv fzero) .snd

    cutoff+- : cutoff + (m ‚à∏ cutoff) ‚â° m
    cutoff+- =
      cutoff + (m ‚à∏ cutoff) ‚â°‚ü® +-comm cutoff _ ‚ü©
      (m ‚à∏ cutoff) + cutoff ‚â°‚ü® ‚â§-‚à∏-+-cancel (<-weaken cutoff<) ‚ü©
      m ‚àé

    lemma-Œ± : _
    lemma-Œ± (k , p) = ‚äé.rec
      (Œª k<m‚à∏cutoff ->
          _
        ‚â°‚ü® sym (transport-filler _ _) ‚ü©  
          zs (aut .fun (finSubst cutoff+- (‚äé.rec finCombine-inl finCombine-inr (fun ‚äé-swap-Iso (finSplit (m ‚à∏ cutoff) cutoff (k , _))))))
        ‚â°‚ü® congS (Œª z -> zs (aut .fun (finSubst cutoff+- (‚äé.rec (finCombine-inl {m = cutoff}) finCombine-inr (fun ‚äé-swap-Iso z))))) (finSplit-beta-inl k k<m‚à∏cutoff _) ‚ü©
          zs (aut .fun (cutoff + k , _))
        ‚â°‚ü® congS (zs ‚àò aut .fun) (Œ£‚â°Prop (Œª _ -> isProp‚â§) refl) ‚ü©
          zs (aut .fun (finSubst cutoff+- (finCombine cutoff (m ‚à∏ cutoff) (inr (k , k<m‚à∏cutoff)))))
        ‚â°‚ü®‚ü©
          ‚äé.rec
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inr)
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inl)
            (inl (k , k<m‚à∏cutoff))
        ‚â°‚ü® congS (‚äé.rec _ _) (sym (finSplit-beta-inl k k<m‚à∏cutoff p)) ‚ü©
          ‚äé.rec
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inr)
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inl)
            (finSplit (m ‚à∏ cutoff) cutoff (k , p))
      ‚àé)
      (Œª m‚à∏cutoff‚â§k ->
          _
        ‚â°‚ü® sym (transport-filler _ _) ‚ü©  
          zs (aut .fun (finSubst cutoff+- (‚äé.rec finCombine-inl finCombine-inr (fun ‚äé-swap-Iso (finSplit (m ‚à∏ cutoff) cutoff (k , _))))))
        ‚â°‚ü® congS (Œª z -> zs (aut .fun (finSubst cutoff+- (‚äé.rec (finCombine-inl {m = cutoff}) finCombine-inr (fun ‚äé-swap-Iso z))))) (finSplit-beta-inr k _ m‚à∏cutoff‚â§k (‚à∏-<-lemma (m ‚à∏ cutoff) cutoff k p m‚à∏cutoff‚â§k)) ‚ü©
          zs (aut .fun (finSubst cutoff+- (finCombine-inl (k ‚à∏ (m ‚à∏ cutoff) , ‚à∏-<-lemma (m ‚à∏ cutoff) cutoff k p m‚à∏cutoff‚â§k))))  
        ‚â°‚ü® congS (zs ‚àò aut .fun ‚àò finSubst cutoff+-) (Œ£‚â°Prop (Œª _ -> isProp‚â§) refl) ‚ü©
          zs (aut .fun (finSubst cutoff+- (finCombine cutoff (m ‚à∏ cutoff) (inl (k ‚à∏ (m ‚à∏ cutoff) , ‚à∏-<-lemma (m ‚à∏ cutoff) cutoff k p m‚à∏cutoff‚â§k)))))
        ‚â°‚ü® congS (‚äé.rec _ _) (sym (finSplit-beta-inr k p m‚à∏cutoff‚â§k (‚à∏-<-lemma (m ‚à∏ cutoff) cutoff k p m‚à∏cutoff‚â§k))) ‚ü©
          ‚äé.rec
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inr)
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inl)
            (finSplit (m ‚à∏ cutoff) cutoff (k , p))
      ‚àé)
      (k ‚â§? (m ‚à∏ cutoff))
    
    lemma-Œ≤ : _
    lemma-Œ≤ (k , p) = ‚äé.rec
      (Œª k<cutoff ->
          _
        ‚â°‚ü® sym (transport-filler _ _) ‚ü©
          ‚äé.rec
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inl)
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inr)
            (finSplit cutoff (m ‚à∏ cutoff) (k , _))
        ‚â°‚ü® congS (‚äé.rec _ _) (finSplit-beta-inl k k<cutoff _) ‚ü©
          ‚äé.rec  
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inl)
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inr)
            (inl (k , _))
        ‚â°‚ü®‚ü©
          zs (aut .fun (finSubst cutoff+- (finCombine cutoff (m ‚à∏ cutoff) (inl (k , _)))))
        ‚â°‚ü® congS (zs ‚àò aut .fun) (Œ£‚â°Prop (Œª _ -> isProp‚â§) refl) ‚ü©
          zs (aut .fun (k , p))  
      ‚àé)
      (Œª cutoff‚â§k ->
          _
        ‚â°‚ü® sym (transport-filler _ _) ‚ü©
          ‚äé.rec
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inl)
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inr)
            (finSplit cutoff (m ‚à∏ cutoff) (k , _))
        ‚â°‚ü® congS (‚äé.rec _ _) (finSplit-beta-inr k _ cutoff‚â§k (<-‚à∏-< k m cutoff p cutoff<)) ‚ü©
          ‚äé.rec
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inl)
            (zs ‚àò aut .fun ‚àò finSubst cutoff+- ‚àò finCombine cutoff (m ‚à∏ cutoff) ‚àò inr)
            (inr (k ‚à∏ cutoff , _))
        ‚â°‚ü®‚ü©
          zs (aut .fun (finSubst cutoff+- (finCombine cutoff (m ‚à∏ cutoff) (inr (k ‚à∏ cutoff , _)))))
        ‚â°‚ü® congS (zs ‚àò aut .fun) (Œ£‚â°Prop (Œª _ -> isProp‚â§) (+-comm cutoff (k ‚à∏ cutoff) ‚àô ‚â§-‚à∏-+-cancel cutoff‚â§k)) ‚ü©
          zs (aut .fun (k , p))  
      ‚àé)
      (k ‚â§? cutoff)

  permuteInvariant' : ‚àÄ n tag -> n ‚â° tag -- to help termination checker
                  -> (zs : Fin n -> A) (aut : Iso (Fin n) (Fin n))
                  -> f‚ôØ (n , zs ‚àò aut .fun) ‚â° f‚ôØ (n , zs)

  permuteInvariantOnZero : ‚àÄ n tag -> suc (suc n) ‚â° suc tag
                  -> (zs : Fin (suc (suc n)) -> A) (aut : Iso (Fin (suc (suc n))) (Fin (suc (suc n))))
                  -> aut .fun fzero ‚â° fzero
                  -> f‚ôØ (suc (suc n) , zs ‚àò aut .fun) ‚â° f‚ôØ (suc (suc n) , zs)
  permuteInvariantOnZero n tag tag‚â° zs aut aut-0‚â°0 =
      f (zs (aut .fun fzero)) ùîú.‚äï (f‚ôØ (suc n , zs ‚àò aut .fun ‚àò fsuc))
    ‚â°‚ü® congS (Œª z -> f (zs z) ùîú.‚äï (f‚ôØ (suc n , zs ‚àò aut .fun ‚àò fsuc))) (Œ£‚â°Prop (Œª _ -> isProp‚â§) (congS fst aut-0‚â°0)) ‚ü©
      f (zs fzero) ùîú.‚äï (f‚ôØ (suc n , zs ‚àò aut .fun ‚àò fsuc))
    ‚â°‚ü® congS (Œª z -> f (zs fzero) ùîú.‚äï (f‚ôØ z)) (Œ£PathP {x = suc n , zs ‚àò aut .fun ‚àò fsuc} (refl , toPathP (funExt lemma))) ‚ü©
      f (zs fzero) ùîú.‚äï f‚ôØ (suc n , zs ‚àò fsuc ‚àò punchOutZero aut aut-0‚â°0 .fun)
    ‚â°‚ü® cong‚ÇÇ ùîú._‚äï_ (sym (ùîú.unitr _)) (permuteInvariant' (suc n) tag (injSuc tag‚â°) (zs ‚àò fsuc) (punchOutZero aut aut-0‚â°0)) ‚ü©
      f‚ôØ (Œ∑ (zs fzero)) ùîú.‚äï f‚ôØ (suc n , zs ‚àò fsuc)
    ‚â°‚ü® sym (f‚ôØ-hom-‚äï (Œ∑ (zs fzero)) (suc n , zs ‚àò fsuc)) ‚ü©
      f‚ôØ (Œ∑ (zs fzero) ‚äï (suc n , zs ‚àò fsuc))
    ‚â°‚ü® congS f‚ôØ (Œ∑+fsuc zs) ‚ü©
      f‚ôØ (suc (suc n) , zs) ‚àé
    where
    lemma : _
    lemma w =
        transport (Œª _ -> A) (zs (aut .fun (fsuc (transport (Œª _ ‚Üí Fin (suc n)) w))))
      ‚â°‚ü® sym (transport-filler _ _) ‚ü©
        zs (aut .fun (fsuc (transport (Œª _ ‚Üí Fin (suc n)) w)))
      ‚â°‚ü® congS (Œª z -> zs (aut .fun (fsuc z))) (sym (transport-filler _ _)) ‚ü©
        zs (aut .fun (fsuc w))
      ‚â°‚ü® congS zs (punchOutZero‚â°fsuc aut aut-0‚â°0 w) ‚ü©
        zs (fsuc (punchOutZero aut aut-0‚â°0 .fun w)) ‚àé

  permuteInvariant' (suc (suc n)) zero tag‚â° zs aut =
    ‚ä•.rec (snotz tag‚â°)
  permuteInvariant' zero _ _ zs aut =
    congS f‚ôØ (Œ£PathP {x = 0 , zs ‚àò aut .fun} {y = 0 , zs} (refl , funExt (‚ä•.rec ‚àò ¬¨Fin0)))
  permuteInvariant' (suc zero) _ _ zs aut =
    congS f‚ôØ (Œ£PathP {x = 1 , zs ‚àò aut .fun} {y = 1 , zs} (refl , lemma))
    where
    lemma : _
    lemma =
      zs ‚àò aut .fun ‚â°‚ü® congS (zs ‚àò_) (isContr‚ÜíisProp (isContrŒ† (Œª _ -> isContrFin1)) (aut .fun) (idfun _)) ‚ü©
      zs ‚àò idfun _ ‚â°‚ü®‚ü©
      zs ‚àé
  permuteInvariant' (suc (suc n)) (suc tag) tag‚â° zs aut =
      f‚ôØ (suc (suc n) , zs ‚àò aut .fun)
    ‚â°‚ü® sym (swapAutToAut zs aut) ‚ü©
      f‚ôØ (suc (suc n) , zs ‚àò swapAut aut .fun)
    ‚â°‚ü® permuteInvariantOnZero n tag tag‚â° zs (swapAut aut) (swapAut0‚â°0 aut) ‚ü©
      f‚ôØ (suc (suc n) , zs) ‚àé

  permuteInvariant : ‚àÄ n (zs : Fin n -> A) (aut : Iso (Fin n) (Fin n)) -> f‚ôØ (n , zs ‚àò aut .fun) ‚â° f‚ôØ (n , zs)
  permuteInvariant n = permuteInvariant' n n refl

  symm-resp-f‚ôØ : {as bs : Array A} -> SymmAction as bs -> f‚ôØ as ‚â° f‚ôØ bs
  symm-resp-f‚ôØ {as = n , g} {bs = m , h} (œÉ , p) =
      f‚ôØ (n , g)
    ‚â°‚ü® congS (Œª z -> f‚ôØ (n , z)) p ‚ü©
      f‚ôØ (n , h ‚àò œÉ .fun)
    ‚â°‚ü® congS f‚ôØ (Œ£PathP (n‚â°m , toPathP (funExt lemma))) ‚ü©
      f‚ôØ (m , h ‚àò œÉ .fun ‚àò (finIso (sym n‚â°m)) .fun)
    ‚â°‚ü®‚ü©
      f‚ôØ (m , h ‚àò (compIso (finIso (sym n‚â°m)) œÉ) .fun)
    ‚â°‚ü® permuteInvariant m h (compIso (finIso (sym n‚â°m)) œÉ) ‚ü©
      f‚ôØ (m , h) ‚àé
    where
    n‚â°m : n ‚â° m
    n‚â°m = symm-length‚â° œÉ

    lemma : _
    lemma (w , q) =
      _ ‚â°‚ü® sym (transport-filler _ _) ‚ü©
      h (œÉ .fun (subst Fin (sym n‚â°m) (w , q))) ‚àé

module _ {‚Ñì} (A : Type ‚Ñì) where
  open import Cubical.Relation.Binary
  module P = BinaryRelation {A = Array A} SymmAction
  open isPermRel

  isPermRelPerm : isPermRel arrayDef (SymmAction {A = A})
  P.isEquivRel.reflexive (isEquivRel isPermRelPerm) _ = symm-refl
  P.isEquivRel.symmetric (isEquivRel isPermRelPerm) _ _ = symm-sym
  P.isEquivRel.transitive (isEquivRel isPermRelPerm) _ _ cs = symm-trans {cs = cs}
  isCongruence isPermRelPerm {as} {bs} {cs} {ds} p q = symm-cong p q
  isCommutative isPermRelPerm = symm-comm
  resp-‚ôØ isPermRelPerm {isSetùîú = isSetùîú} ùîú-cmon f p = symm-resp-f‚ôØ isSetùîú ùîú-cmon f p
      