{-# OPTIONS --cubical #-}

module Cubical.Structures.Set.Free where

open import Cubical.Foundations.Everything
open import Cubical.Foundations.Equiv
open import Cubical.Functions.Image
open import Cubical.HITs.PropositionalTruncation as P
open import Cubical.Data.Nat
open import Cubical.Data.FinData as F
open import Cubical.Data.List as L
open import Cubical.Data.List.FinData as F
open import Cubical.Data.Sigma
open import Cubical.Reflection.RecordEquiv
open import Cubical.HITs.SetQuotients as Q
open import Agda.Primitive

open import Cubical.Structures.Set.Sig
open import Cubical.Structures.Set.Str
open import Cubical.Structures.Set.Tree
open import Cubical.Structures.Set.Eq

-- defines a free structure on a signature and equations
module Definition (σ : Sig ℓ-zero ℓ-zero) (τ : EqSig ℓ-zero ℓ-zero) (ε : seq σ τ) where
  record Free : Type (ℓ-suc ℓ-zero) where
    field
      F : (X : Type) -> Type
      η : {X : Type} -> X -> F X
      α : {X : Type} -> sig σ (F X) -> F X
      sat : {X : Type} -> mkStruct (F X) α ⊨ ε
      isFree : {X : Type} {𝔜 : struct σ} (ϕ : 𝔜 ⊨ ε)
            -> isEquiv (\(f : structHom (mkStruct (F X) α) 𝔜) -> f .fst ∘ η)

    ext : {X : Type} {𝔜 : struct σ} (ϕ : 𝔜 ⊨ ε)
       -> (h : X -> 𝔜 .carrier) -> structHom (mkStruct (F X) α) 𝔜
    ext ϕ = invIsEq (isFree ϕ)

    ext-β : {X : Type} {𝔜 : struct σ} (ϕ : 𝔜 ⊨ ε) (H : structHom (mkStruct (F X) α) 𝔜)
         -> ext ϕ (H .fst ∘ η) ≡ H
    ext-β ϕ H = retIsEq (isFree ϕ) H

    ext-η : {X : Type} {𝔜 : struct σ} (ϕ : 𝔜 ⊨ ε) (h : X -> 𝔜 .carrier)
         -> (ext ϕ h .fst) ∘ η ≡ h
    ext-η ϕ h = secIsEq (isFree ϕ) h

-- constructions of a free structure on a signature and equations
-- TODO: generalise the universe levels!!
-- using a HIT
module Construction (σ : Sig ℓ-zero ℓ-zero) (τ : EqSig ℓ-zero ℓ-zero) (ε : seq σ τ) where

  data Free (X : Type) : Type ℓ-zero where
      η : X -> Free X
      α : sig σ (Free X) -> Free X
      sat : mkStruct (Free X) α ⊨ ε

  freeStruct : (X : Type) -> struct σ
  carrier (freeStruct X) = Free X
  algebra (freeStruct _) = α

  module _ (X : Type) (𝔜 : struct σ) (ϕ : 𝔜 ⊨ ε) where

    -- private
    --   Y = 𝔜 .fst
    --   β = 𝔜 .snd

    -- ext : (h : X -> Y) -> Free X -> Y
    -- ext h (η x) = h x
    -- ext h (α (f , o)) = β (f , (ext h ∘ o))
    -- ext h (sat e ρ i) = ϕ e (ext h ∘ ρ) {!i!}

    -- module _  where
    --   postulate
    --     Fr : Type (ℓ-max (ℓ-max f a) n)
    --     Fα : sig σ Fr -> Fr
    --     Fs : sat σ τ ε (Fr , Fα)

    --   module _ (Y : Type (ℓ-max (ℓ-max f a) n)) (α : sig σ Y -> Y) where
    --     postulate
    --       Frec : sat σ τ ε (Y , α) -> Fr -> Y
    --       Fhom : (p : sat σ τ ε (Y , α)) -> walgIsH σ (Fr , Fα) (Y , α) (Frec p)
    --       Feta : (p : sat σ τ ε (Y , α)) (h : Fr -> Y) -> walgIsH σ (Fr , Fα) (Y , α) h -> Frec p ≡ h

-- using a quotient
module Construction2 (σ : Sig ℓ-zero ℓ-zero) (τ : EqSig ℓ-zero ℓ-zero) (ε : seq σ τ) where

  -- congruence relation generated by equations
  data _≈_ {X : Type} : Tr σ X -> Tr σ X -> Type (ℓ-suc ℓ-zero) where
    ≈-refl : ∀ t -> t ≈ t
    ≈-sym : ∀ t s -> t ≈ s -> s ≈ t
    ≈-trans : ∀ t s r -> t ≈ s -> s ≈ r -> t ≈ r
    ≈-cong : (f : σ .symbol) -> {t s : σ .arity f -> Tr σ X}
          -> ((a : σ .arity f) -> t a ≈ s a)
          -> node (f , t) ≈ node (f , s)
    ≈-eqs : (𝔜 : struct {ℓ-zero} {ℓ-zero} {ℓ-zero} σ) (ϕ : 𝔜 ⊨ ε)
         -> (e : τ .name) (ρ : X -> 𝔜 .carrier)
         -> ∀ t s -> sharp σ 𝔜 ρ t ≡ sharp σ 𝔜 ρ s
         -> t ≈ s

  Free : Type -> Type₁
  Free X = Tr σ X / _≈_

  -- freeAlg : (X : Type) -> sig σ (Free X) -> Free X
  -- freeAlg X (f , i) = Q.[ node (f , {!!}) ] -- needs choice?

  -- freeStruct : (X : Type) -> struct σ
  -- freeStruct X = Free X , freeAlg X

  -- module _ (X : Type) (𝔜 : struct σ) (ϕ : 𝔜 ⊨ ε) where

  --   private
  --     Y = 𝔜 .fst
  --     β = 𝔜 .snd
