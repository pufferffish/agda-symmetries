{-# OPTIONS --cubical #-}

module Cubical.Structures.Set.Free where

open import Cubical.Foundations.Everything
open import Cubical.Foundations.Equiv
open import Cubical.Functions.Image
open import Cubical.HITs.PropositionalTruncation as P
open import Cubical.Data.Nat
open import Cubical.Data.FinData as F
open import Cubical.Data.List as L
open import Cubical.Data.List.FinData as F
open import Cubical.Data.Sigma
open import Cubical.Reflection.RecordEquiv
open import Cubical.HITs.SetQuotients as Q
open import Agda.Primitive

open import Cubical.Structures.Set.Sig
open import Cubical.Structures.Set.Str
open import Cubical.Structures.Set.Tree
open import Cubical.Structures.Set.Eq

-- defines a free structure on a signature and equations
module Definition (Ïƒ : Sig â„“-zero â„“-zero) (Ï„ : EqSig â„“-zero â„“-zero) (Îµ : seq Ïƒ Ï„) where
  record Free : Type (â„“-suc â„“-zero) where
    field
      F : (X : Type) -> Type
      Î· : {X : Type} -> X -> F X
      Î± : {X : Type} -> sig Ïƒ (F X) -> F X
      sat : {X : Type} -> (F X , Î±) âŠ¨ Îµ
      isFree : {X : Type} {ğ”œ : struct Ïƒ} (Ï• : ğ”œ âŠ¨ Îµ)
            -> isEquiv (\(f : structHom Ïƒ (F X , Î±) ğ”œ) -> f .fst âˆ˜ Î·)

    ext : {X : Type} {ğ”œ : struct Ïƒ} (Ï• : ğ”œ âŠ¨ Îµ)
       -> (h : X -> ğ”œ .fst) -> structHom Ïƒ (F X , Î±) ğ”œ
    ext Ï• = invIsEq (isFree Ï•)

    ext-Î² : {X : Type} {ğ”œ : struct Ïƒ} (Ï• : ğ”œ âŠ¨ Îµ) (H : structHom Ïƒ (F X , Î±) ğ”œ)
         -> ext Ï• (H .fst âˆ˜ Î·) â‰¡ H
    ext-Î² Ï• H = retIsEq (isFree Ï•) H

    ext-Î· : {X : Type} {ğ”œ : struct Ïƒ} (Ï• : ğ”œ âŠ¨ Îµ) (h : X -> ğ”œ .fst)
         -> (ext Ï• h .fst) âˆ˜ Î· â‰¡ h
    ext-Î· Ï• h = secIsEq (isFree Ï•) h

-- constructions of a free structure on a signature and equations
-- TODO: generalise the universe levels!!
-- using a HIT
module Construction (Ïƒ : Sig â„“-zero â„“-zero) (Ï„ : EqSig â„“-zero â„“-zero) (Îµ : seq Ïƒ Ï„) where

  data Free (X : Type) : Type â„“-zero where
      Î· : X -> Free X
      Î± : sig Ïƒ (Free X) -> Free X
      sat : (Free X , Î±) âŠ¨ Îµ

  freeStruct : (X : Type) -> struct Ïƒ
  freeStruct X = Free X , Î±

  module _ (X : Type) (ğ”œ : struct Ïƒ) (Ï• : ğ”œ âŠ¨ Îµ) where

    private
      Y = ğ”œ .fst
      Î² = ğ”œ .snd

    -- ext : (h : X -> Y) -> Free X -> Y
    -- ext h (Î· x) = h x
    -- ext h (Î± (f , o)) = Î² (f , (ext h âˆ˜ o))
    -- ext h (sat e Ï i) = Ï• e (ext h âˆ˜ Ï) {!i!}

    -- module _  where
    --   postulate
    --     Fr : Type (â„“-max (â„“-max f a) n)
    --     FÎ± : sig Ïƒ Fr -> Fr
    --     Fs : sat Ïƒ Ï„ Îµ (Fr , FÎ±)

    --   module _ (Y : Type (â„“-max (â„“-max f a) n)) (Î± : sig Ïƒ Y -> Y) where
    --     postulate
    --       Frec : sat Ïƒ Ï„ Îµ (Y , Î±) -> Fr -> Y
    --       Fhom : (p : sat Ïƒ Ï„ Îµ (Y , Î±)) -> walgIsH Ïƒ (Fr , FÎ±) (Y , Î±) (Frec p)
    --       Feta : (p : sat Ïƒ Ï„ Îµ (Y , Î±)) (h : Fr -> Y) -> walgIsH Ïƒ (Fr , FÎ±) (Y , Î±) h -> Frec p â‰¡ h

-- using a quotient
module Construction2 (Ïƒ : Sig â„“-zero â„“-zero) (Ï„ : EqSig â„“-zero â„“-zero) (Îµ : seq Ïƒ Ï„) where

  -- congruence relation generated by equations
  data _â‰ˆ_ {X : Type} : Tr Ïƒ X -> Tr Ïƒ X -> Type (â„“-suc â„“-zero) where
    â‰ˆ-refl : âˆ€ t -> t â‰ˆ t
    â‰ˆ-sym : âˆ€ t s -> t â‰ˆ s -> s â‰ˆ t
    â‰ˆ-trans : âˆ€ t s r -> t â‰ˆ s -> s â‰ˆ r -> t â‰ˆ r
    â‰ˆ-cong : (f : Ïƒ .symbol) -> {t s : Ïƒ .arity f -> Tr Ïƒ X}
          -> ((a : Ïƒ .arity f) -> t a â‰ˆ s a)
          -> node (f , t) â‰ˆ node (f , s)
    â‰ˆ-eqs : (ğ”œ : struct {â„“-zero} {â„“-zero} {â„“-zero} Ïƒ) (Ï• : ğ”œ âŠ¨ Îµ)
         -> (e : Ï„ .name) (Ï : X -> ğ”œ .fst)
         -> âˆ€ t s -> sharp Ïƒ ğ”œ Ï t â‰¡ sharp Ïƒ ğ”œ Ï s
         -> t â‰ˆ s

  Free : Type -> Typeâ‚
  Free X = Tr Ïƒ X / _â‰ˆ_

  -- freeAlg : (X : Type) -> sig Ïƒ (Free X) -> Free X
  -- freeAlg X (f , i) = Q.[ node (f , {!!}) ] -- needs choice?

  -- freeStruct : (X : Type) -> struct Ïƒ
  -- freeStruct X = Free X , freeAlg X

  module _ (X : Type) (ğ”œ : struct Ïƒ) (Ï• : ğ”œ âŠ¨ Îµ) where

    private
      Y = ğ”œ .fst
      Î² = ğ”œ .snd
