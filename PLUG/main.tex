% !TEX program = lualatex 

\documentclass{beamer}

\usecolortheme{orchid}

\usepackage{hott}
\usepackage{mathtools}
\usepackage{macros}
\usepackage{listings}
\usepackage{microtype}

\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{braket}
\usepackage{mathtools}
\usepackage{commath}
\usepackage{xparse}
\usepackage{array}

\usepackage{tikz}
\usetikzlibrary{cd}
\usetikzlibrary{fit}

\usepackage{fontspec}
\setmonofont{Iosevka}

\lstloadlanguages{Haskell}
\lstdefinelanguage{Agda}{
  language         = Haskell,
  showstringspaces = false,
  xleftmargin      = .01\textwidth,
  xrightmargin     = .01\textwidth,
  columns          = fullflexible,
  keepspaces       = true,
  basewidth        = {0em,0em},
  morekeywords     = {},
  deletekeywords   = {List},
  emph             = [1]{List,Mset,SMC,FMSet,Perm},
  emph             = [2]{i0,i1,hcomp},
  alsoletter       = {_,-},
  escapeinside     = ||,
  moredelim        = **[is][\only<+>{\color{red}}]{@}{@},
  basicstyle       = \ttfamily\color{gray},
  keywordstyle     = \bfseries\color{blue},
  emphstyle        = [1]\bfseries\color{orange},
  emphstyle        = [2]\color{blue},
  identifierstyle  = \color{black},
  stringstyle      = \color{orange},
  commentstyle     = \itshape\color{teal},
  literate         = {->}{{$\rightarrow$}}2
                     {->m}{{$\xrightarrow{Mon}$}}2
                     {->cm}{{$\xrightarrow{CMon}$}}2
                     {lambda}{{λ\!}}2
                     {forall}{{∀}}2
                     {times}{{×}}2 {plus}{{+}}2 {uplus}{{$\uplus$}}2
                     {top}{{$\top$}}2 {bot}{{$\bot$}}2
                     {and}{{∧}}2 {or}{{∨}}2
                     {exists}{{∃}}2
                     {==}{{≡}}2
                     {nil}{{\color{gray}[]}}2
                     {cons}{{\color{gray}::}}2
                     {append}{{\color{gray}++}}2
                     {union}{{\color{gray}$\bigcup$}}2
                     {tensor}{{\color{gray}⊗}}2
                     {sharp}{{\color{gray}\ensuremath{^{\text{\#}}}}}2
}
\lstnewenvironment{code}{\lstset{language=Agda}}{}
\lstdefinestyle{inline}{
  breaklines        = true,
  breakatwhitespace = true
}
\newcommand{\inline}[1]{\lstinline[language=Agda,style=inline]{#1}}
\newcommand{\inlinelabel}[1]{
  \lstinline[language=Agda,style=inline,basicstyle=\ttfamily\tiny\color{solarized-base01}]{#1}
}

%Information to be included in the title page:
\title{On commutativity, total orders, and sorting}
\author[shortname]{
  Wind Wong \inst{1}
  \and Vikraman Choudhury \inst{2}
  \and Simon J. Gay \inst{1}
}
\institute[shortinst]{\inst{1} University of Glasgow \and %
                      \inst{2} Universit\`{a} di Bologna and OLAS Team, INRIA}
\date{February 14, 2024}

\begin{document}

\frame{\titlepage}

\begin{frame}
\frametitle{Motivation}

\begin{itemize}

  \item The goal is to study free monoids and free commutative monoids.

  \item We created a framework to formalize different algebraic structures, free algebras and
their universal properties.

  \item Univalent type theory gives us higher inductive types, which allows us to reason with
    commutativity and equations of algebras. (No setoid hell!)

  \item Using the framework, we study the relationship between sorting and total orders.

\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Homotopy Type Theory}

Homotopy Type Theory extends intensional MLTT and allows us to reason with equivalences more
powerfully.

\begin{itemize}

  \item Function extensionality ($\forall x. \, f(x) = g(x) \rightarrow f = g$)

  \item Quotient types (via higher inductive types)

  \item Mere propositions

  \item Equalities between types (via univalence)

\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Homotopy Type Theory}

Function extensionality ($\forall x. \, f(x) = g(x) \rightarrow f = g$)

\begin{itemize}

  \item MLTT by itself does not have function extensionality

  \item It has to be added as an axiom (we lose canonicity!)

  \item funExt can be derived as a theorem in HoTT

\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Homotopy Type Theory}

Quotient types

\begin{itemize}

  \item In MLTT we can only emulate quotient types with setoids
  \item We need to prove functions are setoid homomorphisms when defining a function
  \item A lot of proof obligation
  \item HoTT lets us define quotient types directly with HITs (no more setoid hell!)

\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Homotopy Type Theory}

Mere propositions

\begin{itemize}

  \item In MLTT we don't have a distinction between sets and propositions (both are types)
  \item We might end up needing a stronger theorem to prove a proposition
  \item E.g. existential proofs are done with $\Sigma$-types, requiring us to construct the element
  \item HoTT allows us to have types that are "mere propositions"
  \item E.g. existential proofs can be done with propositionally truncated $\Sigma$-types (mere existence)
  \item We can use mere existential proofs to prove other propositions, even if we don't have the specific element

\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Homotopy Type Theory}

Equalities between types

\begin{itemize}

  \item In MLTT we don't have equalities between types
  \item HoTT gives us equalities between types by the univalence axiom 
  \item E.g. given $A, B : \mathcal{U}, P : \mathcal{U} \rightarrow \mathcal{U}, A = B$,
        we can get $P(B)$ from $P(A)$ by substitution

\end{itemize}

\begin{block}{Definition}
  Given types $A$ and $B$, $A$ is equivalent to $B$ ($A \simeq B$) if there exists an
  equivalence $A \rightarrow B$.
  A function $f$ is said to be an equivalence if
  $\left( \sum_{g :B \rightarrow A} (f \circ g \sim \mathrm{id}_B) \right) \times \left( \sum_{g:B \rightarrow A} (g \circ f \sim \mathrm{id}_A) \right)$.
\end{block}

\begin{block}{Univalence axiom}
  $(A = B) \simeq (A \simeq B)$
\end{block}


\end{frame}

\begin{frame}
\frametitle{Higher Inductive Types}

\begin{align*}
  \text{isContr}(A) & \coloneqq \sum_{(a:A)} \prod_{(x:A)} (a = x).
  & \text{(e.g. $\mathbf{1}$)} \\
  \text{isProp}(A) & \coloneqq \prod_{(x,y:A)} (x = y).
  & \text{(e.g. $\mathbf{1}, \mathbf{0}$)} \\
  \text{isSet}(A) & \coloneqq \prod_{(x,y:A)} \text{isProp}(x = y).
  & \text{(e.g. $\mathbf{1}, \mathbf{0}, \mathbb{N}, \mathsf{hProp}$)} \\
  \text{isGroupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isSet}(x = y).
  & \text{(e.g. $\mathsf{hSet}$)} \\
  \text{is2Groupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isGroupoid}(x = y).
  & \text{(e.g. $\mathsf{hGroupoid}$)} \\
  \shortvdotswithin{=}
\end{align*}

\end{frame}

\begin{frame}[fragile]
\frametitle{Higher Inductive Types}

\begin{code}
data List (A : Type) : Type where
  nil : List A
  _::_ : A -> List A -> List A

-- Swap list as HIT
data FMSet (A : Type) : Type where
  []    : FMSet A
  _::_  : (x : A) -> (xs : FMSet A) -> FMSet A
  comm  : forall x y xs -> x :: y :: xs == y :: x :: xs
  trunc : isSet (FMSet A)
\end{code}

\end{frame}

\begin{frame}[fragile]
\frametitle{Higher Inductive Types}

\begin{code}
-- Swap list as HIT
data FMSet (A : Type) : Type where
  []    : FMSet A
  _::_  : (x : A) -> (xs : FMSet A) -> FMSet A
  comm  : forall x y xs -> x :: y :: xs == y :: x :: xs
  trunc : isSet (FMSet A)
  -- alternatively
  -- trunc : (x y : FMSet A) -> (p q : x == y) -> p == q

_++_ : ∀ (xs ys : FMSet A) → FMSet A
[] ++ ys = ys
(x :: xs) ++ ys = x :: xs ++ ys
comm x y xs i ++ ys =
  -- proof x :: y :: (xs ++ ys) ≡ y :: x :: (xs ++ ys)
trunc xs zs p q i j ++ ys =
  -- proof cong (_++ ys) p ≡ cong (_++ ys) q
\end{code}

\end{frame}

\begin{frame}[fragile]
\frametitle{Higher Inductive Types}

\begin{code}
-- Set quotient
data _/_ (A : Type) (R : A → A → Type) : Type where
  [_] : (a : A) → A / R
  eq/ : (a b : A) → (r : R a b) → [ a ] ≡ [ b ]
  squash/ : (x y : A / R) → (p q : x ≡ y) → p ≡ q

data Perm {A : Type} : List A -> List A -> Type where
  perm-refl : ∀ {xs} -> Perm xs xs
  perm-swap : ∀ {x y xs ys zs}
    -> Perm (xs ++ x ∷ y ∷ ys) zs
    -> Perm (xs ++ y ∷ x ∷ ys) zs

-- Swap list as quotient
FMSet : Type -> Type
FMSet A = List A / Perm
\end{code}

\end{frame}

\begin{frame}
\frametitle{Cubical Type Theory}

\begin{itemize}

  \item The project is done in Cubical Agda, an implementation of Cubical Type Theory
  \item Cubical Type Theory is a variant of HoTT that preserves computational content for proofs
  \item Univalence is not postulated and can be computationally derived
  \item Axioms are designed to preserve canonicity, using univalence won't destroy computational content of a proof

\end{itemize}


\end{frame}


\end{document}
