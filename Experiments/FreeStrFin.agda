{-# OPTIONS --cubical --type-in-type #-}

module _ where

open import Cubical.Foundations.Everything
open import Cubical.Foundations.Equiv
open import Cubical.Functions.Image
open import Cubical.HITs.PropositionalTruncation as P
open import Cubical.Data.Nat
open import Cubical.Data.FinData as F
open import Cubical.Data.List as L
open import Cubical.Data.List.FinData as F
open import Cubical.Data.Sigma
open import Cubical.Reflection.RecordEquiv
open import Cubical.HITs.SetQuotients as Q
open import Agda.Primitive

record Sig : Typeâ‚ where
  field
    symbol : Type
    arity : symbol -> â„•
open Sig public

module _ (Ïƒ : Sig) where
  sig : Type -> Type
  sig X = Î£ (Ïƒ .symbol) \f -> Fin (Ïƒ .arity f) -> X

  sigF : {X Y : Type} -> (X -> Y) -> sig X -> sig Y
  sigF h (f , i) = f , h âˆ˜ i

module _ (Ïƒ : Sig) where
  struct : Typeâ‚
  struct = Î£ Type (\X -> sig Ïƒ X -> X)

  structIsHom : (ğ”› ğ”œ : struct) (h : ğ”› .fst -> ğ”œ .fst) -> Type
  structIsHom (X , Î±) (Y , Î²) h =
    ((f , i) : sig Ïƒ X) -> Î² (f , h âˆ˜ i) â‰¡ h (Î± (f , i))

  structHom : struct -> struct -> Type
  structHom ğ”› ğ”œ = Î£[ h âˆˆ (ğ”› .fst -> ğ”œ .fst) ] structIsHom ğ”› ğ”œ h

record EqSig : Typeâ‚ where
  field
    name : Type
    free : name -> Type
open EqSig public

data Tree (Ïƒ : Sig) (V : Type) : Type where
  leaf : V -> Tree Ïƒ V
  node : sig Ïƒ (Tree Ïƒ V) -> Tree Ïƒ V

module _ {Ïƒ : Sig} (ğ”› : struct Ïƒ) where
  ext : {V : Type} -> (V -> ğ”› .fst) -> Tree Ïƒ V -> ğ”› .fst
  ext h (leaf v) = h v
  ext h (node (f , i)) = ğ”› .snd (f , (ext h âˆ˜ i))

  extHom : {V : Type} -> (V -> ğ”› .fst) -> structHom Ïƒ (Tree Ïƒ V , node) ğ”›
  extHom h = ext h , \_ â†’ refl

module _ (Ïƒ : Sig) (Ï„ : EqSig) where
  eqs : Type
  eqs = (e : Ï„ .name) -> Tree Ïƒ (Ï„ .free e) Ã— Tree Ïƒ (Ï„ .free e)

module _ {Ïƒ : Sig} {Ï„ : EqSig} where
  infix 30 _âŠ¨_
  _âŠ¨_ : struct Ïƒ -> eqs Ïƒ Ï„ -> Type
  ğ”› âŠ¨ Îµ = (e : Ï„ .name) (Ï : Ï„ .free e -> ğ”› .fst)
       -> ext ğ”› Ï (Îµ e .fst) â‰¡ ext ğ”› Ï (Îµ e .snd)

module Free1 (Ïƒ : Sig) (Ï„ : EqSig) (Îµ : eqs Ïƒ Ï„) where

  -- congruence relation generated by equations
  data _â‰ˆ_ {X : Type} : Tree Ïƒ X -> Tree Ïƒ X -> Typeâ‚ where
    â‰ˆ-refl : âˆ€ t -> t â‰ˆ t
    â‰ˆ-sym : âˆ€ t s -> t â‰ˆ s -> s â‰ˆ t
    â‰ˆ-trans : âˆ€ t s r -> t â‰ˆ s -> s â‰ˆ r -> t â‰ˆ r
    â‰ˆ-cong : (f : Ïƒ .symbol) -> {t s : Fin (Ïƒ .arity f) -> Tree Ïƒ X}
          -> ((a : Fin (Ïƒ .arity f)) -> t a â‰ˆ s a)
          -> node (f , t) â‰ˆ node (f , s)
    â‰ˆ-eqs : (ğ”œ : struct Ïƒ) (Ï• : ğ”œ âŠ¨ Îµ)
         -> (e : Ï„ .name) (Ï : X -> ğ”œ .fst)
         -> âˆ€ t s -> ext ğ”œ Ï t â‰¡ ext ğ”œ Ï t
         -> t â‰ˆ s

  Free : Type -> Typeâ‚
  Free X = Tree Ïƒ X / _â‰ˆ_

  -- test1 : {X : Type} (n : â„•) -> (Fin n -> Free X) -> (Fin n -> Tree Ïƒ X)
  -- test1 zero i ()
  -- test1 (suc n) i zero = {!!} -- ??
  -- test1 (suc n) i (suc k) = test1 n (i âˆ˜ weakenFin) k

  -- freeAlg : (X : Type) -> sig Ïƒ (Free X) -> Free X
  -- freeAlg X (f , i) = Q.[ node (f , {!!}) ] -- needs choice?

  -- freeStruct : (X : Type) -> struct Ïƒ
  -- freeStruct X = Free X , freeAlg X

module Free2 (Ïƒ : Sig) (Ï„ : EqSig) (Îµ : eqs Ïƒ Ï„) where

  mutual
    data Free (X : Type) : Type where
      Î· : X -> Free X
      Î± : sig Ïƒ (Free X) -> Free X
      sat : (Free X , Î±) âŠ¨ Îµ

    -- ext ğ”œ (sharp Ï• h âˆ˜ Ï) (Îµâ‚ e .snd) !=
    -- sharp Ï• h (ext (Free X , Î±) Ï (Îµâ‚ e .snd))

    -- sharp : {X : Type} {ğ”œ : struct Ïƒ} (Ï• : ğ”œ âŠ¨ Îµ) (h : X -> ğ”œ .fst) -> Free X -> ğ”œ .fst
    -- sharp Ï• h (Î· x) = h x
    -- sharp {ğ”œ = ğ”œ} Ï• h (Î± (f , o)) = ğ”œ .snd (f , (sharp Ï• h âˆ˜ o))
    -- sharp Ï• h (sat e Ï i) = Ï• e (sharp Ï• h âˆ˜ Ï) {!i!}
