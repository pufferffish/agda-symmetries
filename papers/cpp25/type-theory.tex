% !TEX root = cpp25-sort.tex

\section{Notation}\label{sec:notation}
The text follows the notational conventions of the HoTT/UF book~\cite{univalentfoundationsprogramHomotopyTypeTheory2013}.
%
The work is formalized in Cubical Agda which uses Cubical Type Theory --
we refer the readers to other works such as~\cite{vezzosiCubicalAgdaDependently2019}
for an in-depth tutorial on Cubical Type Theory and programming in Cubical Agda.

\begin{toappendix}
    \subsection{Function extensionality}

    Within the scope of our work, $\term{funExt}$ is heavily used in
    ~\cref{mon:array} and~\cref{cmon:bag}, where a $n$-element array $A^n$ is defined as lookup functions
    $\Fin[n] \to A$. Therefore, to prove two arrays are equal, we need to show that two functions would be
    equal, which is impossible to do without $\term{funExt}$.

    \subsection{Higher Inductive Types}

    In our work, higher inductive types and set quotients are used extensively to define commutative
    data structures, which we would demonstrate in~\cref{sec:commutative-monoids}.

    \subsection{Univalence}\label{types:univalence}

    Within the scope of our work, we want to primarily work with
    sets, therefore we add the truncation constructor whenever necessary so we need not concern ourselves
    with higher-dimensional paths (or equalities). Since we have multiple constructions of free monoids
    and free commutative monoids, given in~\cref{sec:monoids} and~\cref{sec:commutative-monoids},
    having univalence allows us to easily transport proofs and functions from one construction to another.
    Another instance where univalence is used is the definition of membership proofs in~\cref{comb:member},
    where we want to show to propositions are commutative: i.e. $\forall p, q: \hProp, p \vee q = q \vee p$.
    Since $p$ and $q$ are types, we need univalence to show $p \vee q = q \vee p$ are in fact equal.
\end{toappendix}

We denote the type of types with $\mathcal{U}$, and choose to drop universe levels.
We use $\times$ for product types and $+$ for coproduct types.
For mere propositions, we use $\land$ to denote conjunction,
and $\vee$ to denote logical disjunction (truncated coproduct).
We use $\Fin[n]$ to denote finite sets of cardinality $n$ in HoTT.
$\hProp$ and $\hSet$ denote the universe of propositions and sets, respectively,
and we write $\Set$ to denote the (univalent) category of sets and functions.
