% !TEX root = cpp25-sort.tex

\section{Notation}\label{sec:notation}
As we have explained, our work is formalized in Cubical Agda and Cubical Type Theory,
which is a variant of Homotopy Type Theory that is designed to preserve
computational properties of type theory.
We refer the readers to other works such as~\cite{vezzosiCubicalAgdaDependently2019}
and~\cite{cohenCubicalTypeTheory2018} for a more in-depth explanation on Cubical Type Theory
and how we can program in Cubical Agda.
We give a quick overview of the type theory notation in use in this paper.
We also give an overview of relevant features
in Cubical Type Theory which normal type theory (namely MLTT) lacks, and how these features
are used within the scope of our work in~\cref{sec:type-theory}.

\begin{toappendix}
\section{Type Theory}\label{sec:type-theory}
\subsection{Function extensionality}
Function extensionality $\term{funExt}$ states that given two functions $f$ and $g$,
$\term{funExt}: \forall x.\,f(x) = g(x) \to f = g$. MLTT by itself does not have $\term{funExt}$,
instead it has to be postulated as an axiom, thereby losing canonicity, in other words,
we would not be able to compute any constructions of elements that involve $\term{funExt}$
in its construction. In Cubical Type Theory, we can derive $\term{funExt}$
as a theorem while also preserving canoncity, therefore we can compute with constructions
involving $\term{funExt}$!

Within the scope of our work, $\term{funExt}$ is heavily used in
~\cref{mon:array} and~\cref{cmon:bag}, where a $n$-element array $A^n$ is defined as lookup functions
$\Fin[n] \to A$. Therefore, to prove two arrays are equal, we need to show that two functions would be
equal, which is impossible to do without $\term{funExt}$. We also would not be able to normalize
any constructions of arrays which involve $\term{funExt}$ if it is postulated as an axiom, therefore
the computational property of Cubical Type Theory is really useful for us.

\subsection{Higher Inductive Types}
Higher inductive types~\cite{cavalloHigherInductiveTypes2019}
allow us to extend inductive types to not only allow point constructors
but also path constructors, essentially equalities between elements of the HIT. One such example
would be the following definition of $\mathbb{Z}$:


\begin{code}
data $\mathbb{Z}$ : UU where
    pos : (n : $\mathbb{N}$) -> $\mathbb{Z}$
    neg: (n : $\mathbb{N}$) -> $\mathbb{Z}$
    posneg : pos 0 == neg 0
\end{code}


The integers are often represented with a $\term{pos} : \Nat \to \mathbb{Z}$
and $\term{negsuc} : \Nat \to \mathbb{Z}$, where natural numbers
are mapped into the integers via the $\term{pos}$ constructor, and negative numbers are constructed
by mapping $n : \Nat$ to $-(n + 1)$. The shifting by one is done to avoid having duplicate elements
for 0, which can easily lead to confusion. HIT allows us to define integers more naturally by saying
$\term{pos}(0) = \term{neg}(0)$, avoiding the confusing shift-by-one hack.

One can see how we can define a general data type for set quotients. Here is the definition:

\begin{code}
data _/_ (A : UU) (R : A -> A -> UU) : UU where
    [_]  : A -> A / R
    q/ : (a b : A) -> (r : R a b) -> [ a ] == [ b ]
    trunc : (x y : A / R) -> (p q : x = y) -> p = q
\end{code}


The $\term{q/}$ constructor says if $a$ and $b$ can be identified by a relation $R$, then
they should belong to the same quotient generated by $R$.
One might also notice the $\term{trunc}$ constructor, which says and proofs of $x =_{A/R} y$ are equal.
This constructor basically truncates the $\term{\_/\_}$ type down to set, so that we do not have to
concern ourselves with higher paths generated by the $\term{q/}$ constructor.
We give a more precise definition of "set" in Homotopy Type Theory and examples of types that are
higher dimension than sets in~\cref{types:univalence}.

In our work, higher inductive types and set quotients are used extensively to define commutative
data structures, which we would demonstrate in~\cref{sec:commutative-monoids}. In MLTT we can only
reason with quotients and commutativity by setoids, which comes with a lot of proof burden
since we cannot work with the type theory's definition of equalities and functions directly,
instead we have to define our own equality relation and define our own type for setoid homomorphisms,
giving rise to the infamous setoid hell.

\subsection{Univalence}\label{types:univalence}
In MLTT we cannot construct equalities between types. Univalence, the core of Homotopy Type Theory,
gives us equalities between types by the univalence axiom. To see how this is useful,
consider $A, B : \mathcal{U}, P : \mathcal{U} \rightarrow \mathcal{U}, A = B$, we can
get $P(B)$ from $P(A)$ by transport (or substitution).

\begin{definition}[Univalence axiom]
    $(A = B) \simeq (A \simeq B)$
\end{definition}
Essentially, if we can construct an equivalence between two types $A$ and $B$,
we can obtain a equality of the types $A$ and $B$. While in HoTT we cannot
compute with elements constructed with univalence since it is postulated as an
axiom, Cubical Type Theory allows us to derive univalence as a computable
theorem, therefore we can transport functions and proofs from one type to
another freely without worrying about terms not being able to normalize!

Within the scope of our work, we want to primarily work with
sets, therefore we add the truncation constructor whenever necessary so we need not concern ourselves
with higher-dimension paths (or equalities). Since we have multiple constructions of free monoids
and free commutative monoids, given in~\cref{sec:monoids} and~\cref{sec:commutative-monoids},
having univalence allows us to easily transport proofs and functions from one construction to another.
Another instance where univalence is used is the definition of membership proofs in~\cref{comb:member},
where we want to show to propositions are commutative: i.e. $\forall p, q: \hProp, p \vee q = q \vee p$.
Since $p$ and $q$ are types, we need univalence to show $p \vee q = q \vee p$ are in fact equal.
\end{toappendix}

We denote the type of types with $\mathcal{U}$.
In practice, $\mathcal{U}$ would be indexed by a type level
Ã  la Russell for consistency, however we opted to omit the type level
for simplicity and clarity.
We use $\Fin[n]$ to denote finite sets of cardinality $n$ in HoTT~\cite{yorgeyCombinatorialSpeciesLabelled2014a}.
This is defined as follows:

\begin{code}
Fin : $\mathbb{N}$ -> UU
Fin n = $\Sigma$[ m $\in$ $\mathbb{N}$ ] (m < n)
\end{code}

There are other ways to define $\Fin$, most notably as an indexed inductive type.
In our construction we opted to use the $\Sigma$-type definition
because cubical Agda does not behave well
when pattern matching on indexed inductive types.

We also use $\times$ to denote product types and $+$ to denote coproduct types.
For mere propositions, we use $\land$ to denote logical and, and $\vee$ to denote logical or.
In Cubical Agda these are defined as propositionally-truncated products and coproducts.