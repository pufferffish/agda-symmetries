\section{Discussion}
\label{sec:discussion}

We conclude by discussing some high-level observations, related work, and future directions.

\subsection*{Free commutative monoids}

The construction of finite multisets and free commutative monoids has a long history, and various authors have different
approaches to it. We refer the reader to the discussions
in~\cite{choudhuryFreeCommutativeMonoids2023,joramConstructiveFinalSemantics2023} for a detailed survey of these
constructions.
%
Our work, in particular, was motivated by the colloquial observation that:
``there is no way to represent free commutative monoids using inductive types''.
%
From the categorical point of view, this is simply the fact that the free commutative monoid endofunctor on $\Set$ is
not polynomial (doesn't preserve pullbacks).
%
This has led various authors to think about clever encodings of free commutative monoids using inductive types by adding
assumptions on the carrier set -- in particular, the assumption of total ordering on the carrier set leads to the
construction of ``fresh-lists'', by~\cite{kupkeFreshLookCommutativity2023}, which was the inspiration for our work!

Perhaps it is worth noting what this observation means for functional programmers.
%
In programming practice, it is usually the case that all user-defined types have some sort of total order on them,
either because they're finite, or they can be enumerated in some way.
%
Therefore, under these assumptions, the construction of fresh lists is a very reasonable way to represent free
commutative monoids, or finite multisets.

\subsection*{Sorting}

Sorting is a classic problem in computer science, and the functional programming view of sorting and its correctness has
been studied by various authors.
%
The simplest view of sorting is a function $\term{sort}: \LL(\Nat) \to \LL(\Nat)$,
which permutes the list and outputs an ordered list, which is studied in~\cite{appelVerifiedFunctionalAlgorithms2023}.
%
Fundamentally, this is a very extrinsic view of program verification, which is common in the \emph{Coq} community,
and further, a very special case of a more general sorting algorithm.
%
The more refined intrinsic view of correct sorting has been studied in~\cite{hinzeSortingBialgebrasDistributive2012},
and further expanded in~\cite{alexandruIntrinsicallyCorrectSorting2023}, which matches our point of view, as explained
in~\cref{prop:sort-correctness}.
%
Their work is not just about extensional correctness of sorting, but also deriving various sorting algorithms
starting from bialgebraic semantics and distributive laws.
%
Our work is complementary to theirs, in that we are not concerned with the computational content of sorting, but rather
the abstract properties of sorting functions, which are independent of a given ordering.
%
It remains to be seen how these ideas could be combined -- the abstract property of sorting, with the intrinsic essence
of sorting algortihms -- and that is a direction for future work.
%
We do want to point out a fascinating connection between our work and theirs: our observation of recovering $\leq$ from
the section, by ``sorting'' a 2-element list actually appears in a correctness proof
in~\cite[Section~4.6,pg.324]{hengleinSortingSearchingDistribution2013}!

This paper only talks about sorting lists and bags, but the abstract property of correct sorting functions could be
applied to more general inductive types! We speculate that this could lead to some interesting connections with sorting
(binary) trees, and constructions of (binary) search trees, from classical computer science.

\subsection*{Algebra}

One of the contributions of our work is also a rudimentary framework for universal algebra, but done in a more
categorical style, which lends itself to an elegant formalization in type theory.
%
We believe this framework could be improved and generalised to higher dimensions, moving from sets to groupoids,
and using a system of coherences on top of a system of equations, which we are already pursuing.
%
Groupoidyfing free (commutative) monoids to free (symmetric) monoidal groupoids is a natural next step, and its
connections to assumptions about total orders on the type of objects would be an important direction to explore.


% To conclude, our framework of universal algebra can be generalised from sets to groupoids, using a system of
% coherences on top of the system of equations.

% Hinze's work: Sorting and Searching by Distribution: From Generic Discrimination to Generic Trie, see 4.6 on page 324


% \vc{Can you sort anything that doesn't have a total order?}
% \vc{Can you sort binary trees?}

% In a sense, this problem has already been solved, first by Hinze et al. \cite{hinzeSortingBialgebrasDistributive2012}
% and later extended by Alexandru in their thesis \cite{alexandruIntrinsicallyCorrectSorting2023}.
% Their formalization is defined in terms of bialgebras, which not
% only captures the correctness of sorting algorithms purely in a categorical settings, but
% also isolate the computational essence of sorting algorithms in terms of distributive laws,
% allowing us to construct more sorting algorithms "for free". Their work are thus necessarily
% below the level of extensional equality, i.e. input-output behavior, and allow us to reason
% with the structures of the sorting algorithms themselves. Our work only concerns the correctness
% of sorting algorithms, with the goal to axiomatize sorting functions as functions satisfying
% some abstract properties, independent of a given ordering, which allows us to gain
% insight into how sorting relates to order and vice versa.
% % and its implications on axiom of choice.
% % maybe write more on its relationship to AC, in a sepreate paragraph?
